// https://renecutura.eu v0.6.3 Copyright 2022 Rene Cutura
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).druid=t.druid||{})}(this,(function(t){"use strict";function e(t,e){return Math.sqrt(r(t,e))}function r(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let n=0;n<r;++n){const r=t[n]-e[n];s+=r*r}return s}function s(t,r,s=e){const i=t.shape[0];let o="precomputed"==s?t:n(t,s),a=new Array(i);for(let t=0;t<i;++t)a[t]=Array.from(o.row(t)).map(((e,r)=>({i:t,j:r,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,r+1);return a}function n(t,r=e){let s=t.shape[0];const n=new _(s,s);for(let e=0;e<s;++e){const i=t.row(e);for(let o=e+1;o<s;++o){const s=r(i,t.row(o));n.set_entry(e,o,s),n.set_entry(o,e,s)}}return n}function i(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let n=r-=1;n>=0;--n)s[n]=(n*e+(r-n)*t)/r;return s}function o(t,r=e){let s=null;if(t instanceof _){let[e,r]=t.shape;if(1===e)s=t.row(0);else{if(1!==r)throw new Error("Matrix must be 1d!");s=t.col(0)}}else s=t;const n=s.length;return r(s,new Float64Array(n))}function a(t){const e=t.length;let r=0,s=0;for(let n=0;n<e;++n){const e=t[n],i=r+e;Math.abs(r)>=Math.abs(e)?s+=r-i+e:s+=e-i+r,r=i}return r+s}function h(t){const[r,s]=t.shape,n=new _(r,s,"identity"),i=new _(s,s,0);for(let h=0;h<s;++h){let s=t.col(h);for(let t=0;t<h;++t){const e=n.col(t),o=a(e.map(((t,e)=>t*s[e])));for(let t=0;t<r;++t)s[t]-=o*e[t];i.set_entry(t,h,o)}const l=o(s,e);for(let t=0;t<r;++t)n.set_entry(t,h,s[t]/l);i.set_entry(h,h,l)}return{R:i,Q:n}}function l(t,e=2,{seed:s=1212,max_iterations:n=100,qr:i=h,tol:o=1e-8}={}){const a=s instanceof c?s:new c(s);t instanceof _||(t=_.from(t));const l=t.shape[0];let{Q:u,R:d}=i(new _(l,e,(()=>2*(a.random-.5))));for(;n--;){const e=u,s=i(t.dot(u));u=s.Q,d=s.R;if(r(u.values,e.values)<o)break}return{eigenvalues:d.diag,eigenvectors:u.transpose().to2dArray}}class _{constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new _(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=(e,r)=>(e===r?1:0)-1/t;for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}static from(t,e="row"){if(t instanceof _)return t.clone();if(_.isArray(t)){let r=t.length;if(0===r)throw new Error("Array is empty");if(_.isArray(t[0])){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw new Error("various array lengths");return new _(r,e,((e,r)=>t[e][r]))}if("row"===e)return new _(1,r,((e,r)=>t[r]));if("col"===e)return new _(r,1,(e=>t[e]));if("diag"===e)return new _(r,r,((e,r)=>e==r?t[e]:0));throw new Error("1d array has NaN entries")}if("number"==typeof t)return new _(1,1,t);throw new Error("error")}row(t){const e=this.values,r=this._cols;return e.subarray(t*r,(t+1)*r)}*iterate_rows(){const t=this._cols,e=this._rows,r=this.values;for(let s=0;s<e;++s)yield r.subarray(s*t,(s+1)*t)}*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}set_row(t,e){const r=this._cols;if(_.isArray(e)&&e.length===r){const s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e[t]}else{if(!(e instanceof _&&e.shape[1]===r&&1===e.shape[0]))throw new Error("Values not valid! Needs to be either an Array, a Float64Array, or a fitting Matrix!");{const s=t*r;for(let t=0;t<r;++t)this.values[s+t]=e._data[t]}}return this}swap_rows(t,e){const r=this._cols,s=this.values;for(let n=t*r,i=e*r,o=0;o<r;++o,++n,++i){const t=s[n];s[n]=s[i],s[i]=t}}col(t){const e=new Float64Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this.values[r*this._cols+t];return e}entry(t,e){return this.values[t*this._cols+e]}set_entry(t,e,r){return this.values[t*this._cols+e]=r,this}add_entry(t,e,r){return this.values[t*this._cols+e]+=r,this}sub_entry(t,e,r){return this.values[t*this._cols+e]-=r,this}transpose(){return new _(this._cols,this._rows,((t,e)=>this.entry(e,t)))}get T(){return this.transpose()}inverse(){const t=this._rows,e=this._cols,r=this.clone(),s=new _(t,e,"I");for(let n=0;n<e;++n){let i=n,o=Math.abs(r.entry(n,n));for(let e=n+1;e<t;++e){const t=Math.abs(r.entry(e,n));o<t&&(i=e,o=t)}if(0===o)throw new Error("Cannot compute inverse of Matrix, determinant is zero");i!==n&&(r.swap_rows(n,i),s.swap_rows(n,i));const a=r.row(n),h=s.row(n);for(let i=0;i<t;++i)if(i!==n){const t=r.row(i),o=s.row(i);if(0!==t[n]){const r=t[n]/a[n];for(let s=n;s<e;++s)t[s]-=r*a[s];for(let t=0;t<e;++t)o[t]-=r*h[t]}}else{const t=a[n];for(let r=n;r<e;++r)a[r]/=t;for(let r=0;r<e;++r)h[r]/=t}}return s}dot(t){if(t instanceof _){let e=this;const[r,s]=e.shape,[n,i]=t.shape;if(s!==n)throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix:\n                A has ${s} cols and B ${n} rows.\n                Must be equal!`);return new _(r,i,((r,n)=>{const o=e.row(r),a=t.values;let h=0;for(let t=0,e=n;t<s;++t,e+=i)h+=o[t]*a[e];return h}))}if(_.isArray(t)){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=a(this.row(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}transDot(t){if(t instanceof _){let e=this;const[r,s]=e.shape,[n,i]=t.shape;if(r!==n)throw new Error(`A.dot(B): A is a ${[s,r].join(" ⨯ ")}-Matrix, B is a ${t.shape.join(" ⨯ ")}-Matrix:\n                A has ${r} cols and B ${n} rows, which must be equal!`);return new _(s,i,((n,o)=>{const a=e.values,h=t.values;let l=0;for(let t=0,e=n,_=o;t<r;++t,e+=s,_+=i)l+=a[e]*h[_];return l}))}if(_.isArray(t)){let e=this._cols;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=a(this.col(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}dotTrans(t){if(t instanceof _){let e=this;const[r,s]=e.shape,[n,i]=t.shape;if(s!==i)throw new Error(`A.dot(B): A is a ${e.shape.join(" ⨯ ")}-Matrix, B is a ${[i,n].join(" ⨯ ")}-Matrix:\n                A has ${s} cols and B ${i} rows, which must be equal!`);return new _(r,n,((r,n)=>{const i=e.row(r),o=t.row(n);let a=0;for(let t=0;t<s;++t)a+=i[t]*o[t];return a}))}if(_.isArray(t)){let e=this._rows;if(t.length!==e)throw new Error(`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`);let r=new Array(e);for(let s=0;s<e;++s)r[s]=a(this.row(s).map((e=>e*t[s])));return r}throw new Error("B must be Matrix or Array")}outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new _;return s.shape=[r,r,(r,n)=>r<=n?e._data[r]*t._data[n]:s.entry(n,r)],s}concat(t,e="horizontal"){const r=this,[s,n]=r.shape,[i,o]=t.shape;if("horizontal"==e){if(s!=i)throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${s} rows, B has ${i} rows.`);const e=new _(s,n+o,"zeros");return e.set_block(0,0,r),e.set_block(0,n,t),e}if("vertical"==e){if(n!=o)throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${n} columns, B has ${o} columns.`);const e=new _(s+i,n,"zeros");return e.set_block(0,0,r),e.set_block(s,0,t),e}if("diag"==e){const e=new _(s+i,n+o,"zeros");return e.set_block(0,0,r),e.set_block(s,n,t),e}throw new Error(`type must be "horizontal" or "vertical", but type is ${e}!`)}set_block(t,e,r){const s=Math.min(this._rows-t,r.shape[0]),n=Math.min(this._cols-e,r.shape[1]);for(let i=0;i<s;++i)for(let s=0;s<n;++s)this.set_entry(i+t,s+e,r.entry(i,s));return this}get_block(t,e,r=null,s=null){const[n,i]=this.shape;if(s=s??i,(r=r??n)<=t||s<=e)throw new Error(`\n                end_row must be greater than start_row, and\n                end_col must be greater than start_col, but\n                end_row = ${r}, start_row = ${t}, end_col = ${s}, and start_col = ${e}!`);const o=new _(r-t,s-e,"zeros");for(let n=t,i=0;n<r;++n,++i)for(let t=e,r=0;t<s;++t,++r)o.set_entry(i,r,this.entry(n,t));return o}gather(t,e){const r=t.length,s=e.length,n=new _(r,s);for(let s=0;s<r;++s){const i=t[s];for(let t=0;t<r;++t){const r=e[t];n.set_entry(s,t,this.entry(i,r))}}return n}_apply_array(t,e){const r=this.values,[s,n]=this.shape;for(let i=0,o=0;o<s;++o)for(let s=0;s<n;++s,++i)r[i]=t(r[i],e(o,s));return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,r)=>t[r]))}_apply_colwise_array(t,e){const r=this.values,[s,n]=this.shape;for(let i=0,o=0;o<s;++o){const s=t[o];for(let t=0;t<n;++t,++i)r[i]=e(r[i],s)}return this}_apply(t,e){const r=this.values,[s,n]=this.shape;if(t instanceof _){const i=t.values,[o,a]=t.shape;if(1===o){if(n!==a)throw new Error("cols !== value_cols");for(let t=0,o=0;o<s;++o)for(let s=0;s<n;++s,++t)r[t]=e(r[t],i[s])}else if(1===a){if(s!==o)throw new Error("rows !== value_rows");for(let t=0,o=0;o<s;++o){const s=i[o];for(let i=0;i<n;++i,++t)r[t]=e(r[t],s)}}else{if(s!=o||n!=a)throw new Error("error");for(let t=0,o=s*n;t<o;++t)r[t]=e(r[t],i[t])}}else if(_.isArray(t))if(t.length===s)for(let i=0,o=0;o<s;++o){const s=t[o];for(let t=0;t<n;++t,++i)r[i]=e(r[i],s)}else{if(t.length!==n)throw new Error("error");for(let i=0,o=0;o<s;++o)for(let s=0;s<n;++s,++i)r[i]=e(r[i],t[s])}else for(let i=0,o=s*n;i<o;++i)r[i]=e(r[i],t);return this}clone(){let t=new _;return t._rows=this._rows,t._cols=this._cols,t._data=this.values.slice(0),t}mult(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,((t,e)=>t*e))}divide(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,((t,e)=>t/e))}add(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,((t,e)=>t+e))}sub(t,{inline:e=!1}={}){return(e?this:this.clone())._apply(t,((t,e)=>t-e))}get shape(){return[this._rows,this._cols]}set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0,n=0;n<t;++n)for(let t=0;t<e;++t,++s)this._data[s]=r(n,t);return this}get to2dArray(){const t=[];for(const e of this.iterate_rows())t.push(e);return t}get asArray(){const t=[];for(const e of this.iterate_rows())t.push(Array.from(e));return t}get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Float64Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}get mean(){return this.sum/(this._rows*this._cols)}get sum(){return a(this.values)}get values(){return this._data}get meanRows(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:e});for(let n=0,i=0;i<e;++i){let e=0;for(let s=0;s<r;++s,++n)e+=t[n];s[i]=e/r}return s}get meanCols(){const t=this.values,e=this._rows,r=this._cols,s=Float64Array.from({length:r});for(let n=0;n<r;++n){let i=0;for(let s=n,o=0;o<e;++o,s+=r)i+=t[s];s[n]=i/e}return s}static solve_CG(t,e,r,s=.001){null===r&&(r=new c);const n=t.shape[0],i=e.shape[1];let o=new _(n,0);for(let a=0;a<i;++a){const i=_.from(e.col(a)).T;let h=new _(n,1,(()=>r.random)),l=i.sub(t.dot(h)),c=l.clone();do{const e=t.dot(c),r=l.transDot(l).entry(0,0)/c.transDot(e).entry(0,0);h=h.add(c.mult(r));const s=l.sub(e.mult(r)),n=s.transDot(s).entry(0,0)/l.transDot(l).entry(0,0);c=s.add(c.mult(n)),l=s}while(Math.abs(l.mean)>s);o=o.concat(h,"horizontal")}return o}static solve(t,e){let{L:r,U:s}="L"in t&&"U"in t?t:_.LU(t),n=r.shape[0],i=e.clone();for(let t=0;t<n;++t){for(let e=0;e<t-1;++e)i.sub_entry(0,t,r.entry(t,e)*i.entry(1,e));i.set_entry(0,t,i.entry(0,t)/r.entry(t,t))}for(let t=n-1;t>=0;--t){for(let e=n-1;e>t;--e)i.sub_entry(0,t,s.entry(t,e)*i.entry(0,e));i.set_entry(0,t,i.entry(0,t)/s.entry(t,t))}return i}static LU(t){const e=t.shape[0],r=new _(e,e,"zeros"),s=new _(e,e,"identity");for(let n=0;n<e;++n){for(let i=n;i<e;++i){let e=0;for(let t=0;t<n;++t)e+=r.entry(i,t)*s.entry(t,n);r.set_entry(i,n,t.entry(i,n)-e)}for(let i=n;i<e;++i){if(0===r.entry(n,n))return;let e=0;for(let t=0;t<n;++t)e+=r.entry(n,t)*s.entry(t,i);s.set_entry(n,i,(t.entry(n,i)-e)/r.entry(n,n))}}return{L:r,U:s}}static det(t){const e=t.shape[0],{L:r,U:s}=_.LU(t),n=r.diag,i=s.diag;let o=n[0]*i[0];for(let t=1;t<e;++t)o*=n[t]*i[t];return o}static SVD(t,e=2){let r=t.transDot(t),s=t.dotTrans(t),{eigenvectors:n,eigenvalues:i}=l(r,e),{eigenvectors:o}=l(s,e);return{U:o,Sigma:i.map((t=>Math.sqrt(t))),V:n}}static isArray(t){return Array.isArray(t)||t instanceof Float64Array||t instanceof Float32Array}}class c{constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}get seed(){return this._seed}get random(){return this.random_int*(1/4294967296)}get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r,s=this._N-this._M,n=this._M-this._N;for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+n]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}gauss_random(){let t,e,r;if(null!=this._val)return t=this._val,this._val=null,t;do{t=2*this.random-1,e=2*this.random-1,r=t*t+e*e}while(!r||r>1);const s=Math.sqrt(-2*Math.log(r)/r);return this._val=e*s,t*s}choice(t,e){if(t instanceof _){let r=t.shape[0];if(e>r)throw new Error("n bigger than A!");let s=new Array(e),n=i(0,r-1);for(let t=0,r=n.length;t<e;++t,--r){let e=this.random_int%r;s[t]=n.splice(e,1)[0]}return s.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let r=t.length;if(e>r)throw new Error("n bigger than A!");let s=new Array(e),n=i(0,r-1);for(let t=0,r=n.length;t<e;++t,--r){let e=this.random_int%r;s[t]=n.splice(e,1)[0]}return s.map((e=>t[e]))}}static choice(t,e,r=1212){return new c(r).choice(t,e)}}function u(t){let e;for(const r of t)null!=r&&(e<r||void 0===e&&r>=r)&&(e=r);return e}function d(t){let e;for(const r of t)null!=r&&(e>r||void 0===e&&r<=r)&&(e=r);return e}class f{constructor(t=null,e=(t=>t),r="min"){return t?f.heapify(t,e,r):(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<e:"max"==r?(t,e)=>t>e:r,this)}static heapify(t,e=(t=>t),r="min"){const s=new f(null,e,r),n=s._container;for(const r of t)n.push({element:r,value:e(r)});for(let e=Math.floor(t.length/2-1);e>=0;--e)s._heapify_down(e);return s}_swap(t,e){const r=this._container;[r[e],r[t]]=[r[t],r[e]]}_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let r=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[r].value))break;this._swap(r,e),e=r}}push(t){const e={element:t,value:this._accessor(t)};return this._container.push(e),this._heapify_up(),this}_heapify_down(t=0){const e=this._container,r=this._comparator,s=e.length;let n=2*t+1,i=2*t+2,o=t;if(o>s)throw"index higher than length";n<s&&r(e[n].value,e[o].value)&&(o=n),i<s&&r(e[i].value,e[o].value)&&(o=i),o!==t&&(this._swap(t,o),this._heapify_down(o))}pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}get first(){return this._container.length>0?this._container[0]:null}*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}data(){return this._container.map((t=>t.element))}raw_data(){return this._container}get length(){return this._container.length}get empty(){return 0===this.length}}class m{constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let r=this.find(t),s=this.find(e);return r===s||(r.__disjoint_set.size<s.__disjoint_set.size&&([r,s]=[s,r]),s.__disjoint_set.parent=r,s.__disjoint_set.children.forEach(r.__disjoint_set.children.add,r.__disjoint_set.children),r.__disjoint_set.size+=s.__disjoint_set.size),this}}class p{constructor(t=null,r=e){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=r,t&&this.add(t),this}add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort(((t,e)=>t.element[r]-e.element[r])),n=s.length,i=Math.floor(n/2),o=t[i],a=s.slice(0,i),h=s.slice(i,n),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=a.length>0&&h.length>0?new this._Node(o,this._construct(a),this._construct(h),l):new this._Leaf(t),e}}_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce(((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t}),r);s=s.map((t=>t[1]-t[0]));let n=0;for(let t=0;t<e;++t)n=s[t]>s[n]?t:n;return n}search(t,e=5){return this._search(t,e,new f(null,(e=>this._metric(e.element,t)),"max"),this._root)}_search(t,e,r,s){if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,n=s.points.length;t<n;++t){let n=s.points[t];e>r.length?r.push(n):(r.push(n),r.pop())}return r}}class w{constructor(t=null,r=e){this._metric=r,this._elements=t instanceof _?t:_.from(t);const s=this._elements.shape[0];this._D="precomputed"===r?this._elements.clone():n(this._elements,r),this.KNN=[];for(let t=0;t<s;++t){const e=this._D.row(t),r=new f(null,(t=>t.value),"min");for(let t=0;t<s;++t)r.push({value:e[t],index:t});this.KNN.push(r)}}search(t,e=5){const r=this._metric,s=this.KNN;let n;if(Array.isArray(t)){if("precomputed"==this._metric)throw"Search by query element is only possible when not using a precomputed distance matrix!";const e=this._elements,i=s.length;let o=null,a=1/0;for(let s=0;s<i;++s){const n=r(t,e.row(s));n<a&&(o=s,a=n)}n=s[o]}else Number.isInteger(t)&&(n=s[t]);let i=[];for(let t=0;t<e;++t)i.push(n.pop());return i.forEach((t=>n.push(t.element))),i}}class g{constructor(t,e,r){if(this._parameters=Object.assign(Object.seal(e),r),Array.isArray(t))this._type="array",this.X=_.from(t);else{if(!(t instanceof _))throw new Error("No valid type for X!");this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._randomizer=new c(this._parameters.seed),this._is_initialized=!1,this}parameter(t=null,e=null){if(null===t)return Object.assign({},this._parameters);if(!this._parameters.hasOwnProperty(t))throw new Error(`${t} is not a valid parameter!`);return null!==e?(this._parameters[t]=e,this._is_initialized=!1,this):this._parameters[t]}para(t=null,e=null){return this.parameter(t,e)}p(t=null,e=null){return this.parameter(t,e)}transform(){return this.check_init(),this.projection}*generator(){return this.transform()}check_init(){return this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0),this}get projection(){if(this.hasOwnProperty("Y"))return this.check_init(),"matrix"===this._type?this.Y:this.Y.to2dArray;throw new Error("The dataset is not transformed yet!")}async transform_async(...t){return this.transform(...t)}static transform(...t){return new this(...t).transform()}static async transform_async(...t){return this.transform(...t)}static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}class y extends g{constructor(t,e){return super(t,{d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(t=null){const e=this.principal_components();if(null==t){const t=this.X;return this.Y=t.dot(e),this.projection}if(Array.isArray(t))return _.from(t).dot(e).asArray;if(t instanceof _)return t.dot(e);throw new Error("No valid type for A!")}principal_components(){if(this.V)return this.V;const{d:t,eig_args:e}=this._parameters,r=this.X,s=r.sub(r.meanCols),n=s.transDot(s),{eigenvectors:i}=l(n,t,e);return this.V=_.from(i).transpose(),this.V}static principal_components(t,e){return new this(t,e).principal_components()}}class A extends g{constructor(t,r){return super(t,{d:2,metric:e,seed:1212,eig_args:{}},r),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){const t=this.X,e=t.shape[0],{d:r,metric:s,eig_args:i}=this._parameters,o="precomputed"===s?t:n(t,s),a=o.meanCols,h=o.meanRows,c=o.mean;this._d_X=o;const u=new _(e,e,((t,e)=>o.entry(t,e)-a[t]-h[e]+c)),{eigenvectors:d}=l(u,r,i);return this.Y=_.from(d).transpose(),this.projection}stress(){const t=this.X.shape[0],r=this.Y,s=this._d_X,n=new _;n.shape=[t,t,(t,s)=>t<s?e(r.row(t),r.row(s)):n.entry(s,t)];let i=0,o=0;for(let e=0;e<t;++e)for(let r=e+1;r<t;++r)i+=Math.pow(s.entry(e,r)-n.entry(e,r),2),o+=Math.pow(s.entry(e,r),2);return Math.sqrt(i/o)}}function x(t,e,r=300){const s=e.length;let n=.001,i=1e4,o=e.slice(),a=t(o),h=!1;for(;r-- >=0&&!h;){h=!0;for(let e=0;e<s;++e){o[e]+=1e-6;let r=t(o);o[e]-=1e-6;let s=(r-a)/1e-6;Math.abs(s)>.01&&(h=!1),o[e]-=n*s,a=t(o)}n*=i>=a?1.05:.4,i=a}return o}class M{constructor(t,e,r,s,n,i,o,a){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=i,this.size=o??e.size+r.size,this.depth=a??1+Math.max(e.depth,r.depth),this.centroid=n??this._calculate_centroid(e,r),this.parent=null,this}_calculate_centroid(t,e){const r=t.size,s=e.size,n=t.centroid,i=e.centroid,o=this.size,a=t.centroid.length,h=new Float64Array(a);for(let t=0;t<a;++t)h[t]=(r*n[t]+s*i[t])/o;return h}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}class b{constructor(t,r,s=null,n=e,i=1212){this._metric=n,this._matrix=t,this._A=this._matrix.to2dArray,this._K=r;const[o,a]=t.shape;return this._N=o,this._D=a,this._max_iter=s||10*Math.log10(o),this._distance_matrix=new _(o,o,"zeros"),r>o&&(r=o),this._randomizer=new c(i),this._clusters=new Array(o).fill(void 0),this._cluster_medoids=this._get_random_medoids(r),this._is_initialized=!1,this}get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{r[this._nearest_medoid(t,e).index_nearest].push(e)})),r.medoids=this._cluster_medoids,r}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,r=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++r<t)}_iteration(){const t=this._A,e=this._K,r=this._cluster_medoids,s=t.map(((t,e)=>this._nearest_medoid(t,e))),n=new Array(e).fill(0),i=new Array(e).fill(null);if(t.forEach(((o,a)=>{if(r.findIndex((t=>t===a))<0){const r=s[a].distance_nearest,h=new Array(e).fill(-r);t.forEach(((t,r)=>{if(a===r)return;const n=this._get_distance(r,a,t,o),{index_nearest:i,distance_nearest:l,distance_second:_}=s[r];if(h[i]+=Math.min(n,_)-l,n<l)for(let t=0;t<e;++t)t!==i&&(h[t]+=n-l)})),h.map(((t,e)=>[t,e])).filter((([t,e])=>t<n[e])).forEach((([t,e])=>{t<n[e]&&(n[e]=t,i[e]=a)}))}})),d(n)>=0)return!0;for(;d(n)<0;){const e=n.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==r.filter((t=>t==i[e])).length&&(r[e]=i[e]),n[e]=0,n.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([i,o])=>{const a=t[o];let h=0;t.forEach(((t,n)=>{r.findIndex((t=>t!=o&&t==n))>=0||e!=o&&(s[n].index_nearest===r[o]?h+=Math.min(this._get_distance(n,o,t,a),s[n].distance_second)-s[n].distance_nearest:h+=Math.min(this._get_distance(n,o,t,a)-s[n].distance_nearest,0))})),n[o]=h}))}return this._cluster_medoids=r,!1}_get_distance(t,e,r=null,s=null){if(t===e)return 0;const n=this._distance_matrix,i=this._A,o=this._metric;let a=n.entry(t,e);return 0===a&&(a=o(r||i[t],s||i[e]),n.set_entry(t,e,a),n.set_entry(e,t,a)),a}_nearest_medoid(t,e){const r=this._cluster_medoids,s=this._A,[n,i]=r.map(((r,n)=>{const i=s[r];return[this._get_distance(e,r,t,i),n]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:n[0],index_nearest:n[1],distance_second:i[0],index_second:i[1]}}init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const r=this._max_iter;let s=!1,n=0;do{s=this._iteration()}while(!s&&++n<r);return this}_get_random_medoids(t){const e=this._N,r=this._A,s=i(0,e-1),n=this._randomizer,o=Math.min(e,10+Math.ceil(Math.sqrt(e))),a=new Array(o).fill(1/0),h=[];let l=1/0,_=n.choice(s,o);for(let t=0;t<o;++t){const e=_[t],s=r[e];for(let e=0;e<o;++e){if(e===t)continue;const n=r[_[e]];a[t]+=this._get_distance(t,e,s,n)}a[t]<l&&(l=a[t],h.push(e))}for(let e=1;e<t;++e){let t=1/0;_=n.choice(s.filter((t=>h.findIndex((e=>e===t))<0)),o);for(let e=0;e<o;++e){let s=0;const n=_[e],i=r[n];for(let t=0;t<o;++t){if(t===e)continue;const o=_[t],a=r[o];let l=this._get_distance(n,o,i,a)-d(h.map((t=>this._get_distance(o,t,a))));l<0&&(s+=l)}s<t&&(t=s,h.push(n))}l+=t}return h.slice(0,t)}}t.BallTree=p,t.DisjointSet=m,t.FASTMAP=class extends g{constructor(t,r){return super(t,{d:2,metric:e,seed:1212},r),this}_choose_distant_objects(t){const e=this.X.shape[0];let r=this._randomizer.random_int%e-1,s=null,n=-1/0;for(let i=0;i<e;++i){const e=t(r,i);e>n&&(n=e,s=i)}n=-1/0;for(let i=0;i<e;++i){const e=t(s,i);e>n&&(n=e,r=i)}return[r,s,n]}transform(){const t=this.X,e=t.shape[0],{d:r,metric:s}=this._parameters,n=new _(e,r,0);let i=(e,r)=>s(t.row(e),t.row(r));for(let t=0;t<r;++t){let r=i;const[s,o,a]=this._choose_distant_objects(i);if(0!==a){for(let r=0;r<e;++r){const e=(i(s,r)**2+a**2-i(o,r)**2)/(2*a);n.set_entry(r,t,e)}i=(e,s)=>Math.sqrt(r(e,s)**2-(n.entry(e,t)-n.entry(s,t))**2)}}return this.Y=n,this.projection}},t.Heap=f,t.Hierarchical_Clustering=class{constructor(t,r="complete",s=e){if(this._id=0,this._matrix=t instanceof _?t:_.from(t),this._metric=s,this._linkage=r,"precomputed"===s&&this._matrix.shape[0]!==this._matrix.shape[1])throw new Error("If metric is 'precomputed', then matrix has to be square!");return this.init(),this.root=this.do(),this}get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=t=>t.dist;break;case"depth":r=t=>t.depth;break;default:throw new Error("invalid type")}return this._traverse(this.root,r,t,s),s}_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r);let n;if("precomputed"!==t){n=new _(r,r,0);for(let i=0;i<r;++i){s[i]=0;for(let o=0;o<r;++o)n.set_entry(i,o,i===o?1/0:t(e.row(i),e.row(o))),n.entry(i,s[i])>n.entry(i,o)&&(s[i]=o)}}else{n=this._matrix.clone();for(let t=0;t<r;++t)for(let e=0;e<r;++e)t===e?n.set_entry(t,e,1/0):n.entry(t,s[t])>n.entry(t,e)&&(s[t]=e)}this._distance_matrix=n;const i=this._clusters=new Array(r),o=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)i[t]=[],i[t][0]=new M(this._id++,null,null,0,e.row(t),t,1,0),o[t]=1;return this}do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,n=this._c_size,i=this._linkage;let o=null;for(let a=0,h=t-1;a<h;++a){let a=0;for(let s=0;s<t;++s){let n=r.entry(s,e[s]);for(let i=s+1;i<t;++i)n>r.entry(s,i)&&(e[s]=i,n=r.entry(s,e[s]))}for(let s=0;s<t;++s)r.entry(s,e[s])<r.entry(a,e[a])&&(a=s);let h=e[a],l=s[a][0],_=s[h][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,d=c.concat(u),f=new M(this._id++,l,_,r.entry(a,h),null,d);l.parent=f,_.parent=f,s[a].unshift(f),n[a]+=n[h];for(let e=0;e<t;++e){const t=r.entry(a,e),s=r.entry(h,e);let o;switch(i){case"single":o=Math.min(t,s);break;case"complete":o=Math.max(t,s);break;case"average":o=(n[a]*t+n[h]*s)/(n[a]+n[e])}r.set_entry(e,a,o),r.set_entry(a,e,o)}r.set_entry(a,a,1/0);for(let e=0;e<t;++e)r.set_entry(e,h,1/0),r.set_entry(h,e,1/0);o=f}return o}},t.ISOMAP=class extends g{constructor(t,r){return super(t,{neighbors:void 0,d:2,metric:e,seed:1212,eig_args:{}},r),this.parameter("neighbors",Math.min(this._parameters.neighbors??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){this.check_init();const t=this.X,e=this._N,{d:r,metric:s,eig_args:n,neighbors:i}=this._parameters,o=new _;o.shape=[e,e,(e,r)=>e<=r?s(t.row(e),t.row(r)):o.entry(r,e)];const a=[];for(let t=0;t<e;++t){const r=[];for(let s=0;s<e;++s)r.push({index:s,distance:o.entry(t,s)});const s=new f(r,(t=>t.distance),"min");a.push(s.toArray().slice(1,i+1))}const h=new _(e,e,((t,e)=>{const r=a[t].find((t=>t.index===e));return r?r.distance:1/0}));for(let t=0;t<e;++t)for(let r=0;r<e;++r){let s=h.entry(t,r);for(let n=0;n<e;++n)s=Math.min(s,h.entry(t,n)+h.entry(n,r));h.set_entry(t,r,s)}let c=new Float64Array(e),u=new Float64Array(e),d=0;const m=new _(e,e,((t,e)=>{let r=h.entry(t,e);return r=r===1/0?0:r,c[t]+=r,u[e]+=r,d+=r,r}));c=c.map((t=>t/e)),u=u.map((t=>t/e)),d/=e**2;const p=new _(e,e,((t,e)=>m.entry(t,e)-c[t]-u[e]+d)),{eigenvectors:w}=l(p,r,n);return this.Y=_.from(w).transpose(),this.projection}},t.KMeans=class{constructor(t,r,s=e,n=1987,i=!0){this._metric=s,this._matrix=t,this._K=r;const[o,a]=t.shape;return this._N=o,this._D=a,r>o&&(r=o),this._randomizer=new c(n),this._clusters=new Array(o).fill(void 0),this._cluster_centroids=this._get_random_centroids(r),i&&this.init(r,this._cluster_centroids),this}get_clusters(){const t=this._K,e=this._clusters,r=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>r[t].push(e))),r}_furthest_point(t,e){const r=this._matrix,s=this._metric;let n=t.length;return f.heapify(e,(e=>{const i=r.row(e);let o=0;for(let e=0;e<n;++e)o+=s(i,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,r=this._randomizer,s=this._matrix,n=new Array(t).fill(),o=i(0,e-1),a=r.random_int%(e-1);n[0]=s.row(a);const h=[a],l=Math.floor((e-t)/t);for(let e=1;e<t;++e){const t=r.choice(o.filter((t=>-1==h.indexOf(t))),l),i=this._furthest_point(n.slice(0,e),t);h.push(i),n[e]=s.row(i)}return n}_iteration(t){const e=t.length,r=this._N,s=this._D,n=this._matrix,i=this._metric,o=this._clusters;let a=!1;for(let s=0;s<r;++s){const r=n.row(s);let h=1/0,l=null;for(let s=0;s<e;++s){let e=i(t[s],r);e<h&&(h=e,l=s)}o[s]!==l&&(a=!0),o[s]=l}for(let r=0;r<e;++r){const e=t[r];for(let t=0;t<s;++t)e[t]=0}return this._compute_centroid(t),{clusters_changed:a,cluster_centroids:t}}_compute_centroid(t){const e=t.length,r=this._N,s=this._D,n=this._matrix,i=this._clusters,o=new Array(e).fill(0);for(let e=0;e<r;++e){const r=n.row(e),a=i[e];o[a]++;const h=t[a];for(let t=0;t<s;++t)h[t]+=r[t]}for(let r=0;r<e;++r){const e=o[r];t[r]=t[r].map((t=>t/e))}}init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let r=!1;do{const t=this._iteration(e);e=t.cluster_centroids,r=t.clusters_changed}while(r)}},t.KMedoids=b,t.KNN=w,t.LDA=class extends g{constructor(t,e){return super(t,{labels:null,d:2,seed:1212,eig_args:{}},e),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){const t=this.X,[e,r]=t.shape,{d:s,labels:n,eig_args:i}=this._parameters;if(null===n||n.length!=e)throw new Error("LDA needs parameter label to every datapoint to work!");const o={};let a=0;n.forEach(((e,r)=>{e in o?(o[e].count++,o[e].rows.push(t.row(r))):o[e]={id:a++,count:1,rows:[t.row(r)]}}));const h=t.mean,c=new _(a,r);for(const t in o){const e=_.from(o[t].rows).meanCols;for(let s=0;s<r;++s)c.set_entry(o[t].id,s,e[s])}let u=new _(r,r);for(const t in o){const e=c.row(o[t].id),s=new _(r,1,(t=>e[t]-h)),n=o[t].count;u=u.add(s.dotTrans(s).mult(n))}let d=new _(r,r);for(const t in o){const e=c.row(o[t].id),s=new _(r,1,(t=>e[t])),n=o[t].rows;for(let e=0,i=o[t].count;e<i;++e){const t=new _(r,1,((t,r)=>n[e][t]-s.entry(t,0)));d=d.add(t.dotTrans(t))}}let{eigenvectors:f}=l(d.inverse().dot(u),s,i);return f=_.from(f).transpose(),this.Y=t.dot(f),this.projection}},t.LLE=class extends g{constructor(t,r){return super(t,{neighbors:void 0,d:2,metric:e,seed:1212,eig_args:{}},r),this.parameter("neighbors",Math.min(r.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this}transform(){const t=this.X,e=this._N,r=this._D,{neighbors:n,d:i,eig_args:o,metric:h}=this._parameters,c=s(t,n,h),u=new _(n,1,1),d=new _(e,e);for(let s=0;s<e;++s){const e=c[s],i=new _(n,r,((r,n)=>t.entry(e[r].j,n)-t.entry(s,n))),o=i.dotTrans(i);if(n>r){const t=a(o.diag)/1e3;for(let e=0;e<n;++e)o.add_entry(e,e,t)}let h=_.solve_CG(o,u,this._randomizer);h=h.divide(h.sum);for(let t=0;t<n;++t)d.set_entry(s,e[t].j,h.entry(t,0))}const f=new _(e,e,"identity").sub(d),m=f.transDot(f),{eigenvectors:p}=l(m.T.inverse(),i+1,o);return this.Y=_.from(p.slice(1,1+i)).T,this.projection}},t.LSP=class extends g{constructor(t,r){return super(t,{neighbors:void 0,control_points:void 0,d:2,metric:e,seed:1212},r),this.parameter("neighbors",Math.min(r.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(r.control_points??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}init(t=A,e={},r=p){if(this._is_initialized)return this;const s=this.X,n=this._N,i=this.parameter("neighbors"),o=this.parameter("d"),a=this.parameter("seed"),h=this.parameter("metric");e=Object.assign({d:o,metric:h,seed:a},e);const l=this.parameter("control_points"),c=new b(s,l,null,h).get_clusters().medoids,u=new _(l,n,"zeros");c.forEach(((t,e)=>{u.set_entry(e,t,1)}));const d=new t(_.from(c.map((t=>s.row(t)))),e).transform(),f=s.to2dArray,m=new r(f,h),w=new _(n,n,"I"),g=-1/i;f.forEach(((t,e)=>{for(const{index:r}of m.search(t,i).iterate())e!==r&&w.set_entry(e,r,g)}));const y=w.concat(u,"vertical"),x=new _(n,o,"zeros").concat(d,"vertical");return this._A=y,this._b=x,this._is_initialized=!0,this}transform(){this.check_init();const t=this._A,e=this._b,r=t.transDot(t),s=t.transDot(e);return this.Y=_.solve_CG(r,s,this._randomizer),this.projection}},t.LTSA=class extends g{constructor(t,r){if(super(t,{neighbors:void 0,d:2,metric:e,seed:1212,eig_args:{}},r),this.parameter("neighbors",Math.min(r.neighbors??Math.max(Math.floor(this._N/10),2),this._N-1)),this._parameters.eig_args.hasOwnProperty("seed")||(this._parameters.eig_args.seed=this._randomizer),this._D<=this.parameter("d"))throw new Error(`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${this.parameter("d")})!`);return this}transform(){const t=this.X,[e,r]=t.shape,{d:n,neighbors:i,metric:o,eig_args:a}=this._parameters,h=s(t,i,o),c=new _(r,r,"center"),u=new _(e,e,0);for(let r=0;r<e;++r){const e=[r,...h[r].map((t=>t.j))];let s=_.from(e.map((e=>t.row(e))));s=s.dot(c);const o=s.dotTrans(s),{eigenvectors:d}=l(o,n,a),f=_.from(d),m=f.transDot(f).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let r=0;r<i+1;++r)u.add_entry(e[t],e[r],m.entry(t,r)-(t===r?1:0))}const{eigenvectors:d}=l(u,n+1,a);return this.Y=_.from(d.slice(1)).transpose(),this.projection}},t.MDS=A,t.Matrix=_,t.OPTICS=class{constructor(t,r,s,n=e){return this._matrix=t,this._epsilon=r,this._min_points=s,this._metric=n,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}init(){const t=this._ordered_list,e=this._matrix,r=e.shape[0],s=this._DB,n=this._clusters;let i=this._cluster_index=0;for(let t=0;t<r;++t)s[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of s)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,n.push([e.index]),i=n.length-1,t.push(e),null!=this._core_distance(e))){const t=new f(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,n[i])}return this}_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,r=this._metric,s=this._epsilon,n=[];for(const i of e)i.index!=t.index&&r(t.element,i.element)<s&&n.push(i);return n}_core_distance(t){const e=this._min_points,r=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return r(t.element,t.neighbors[e].element)}_update(t,e){const r=this._metric,s=this._core_distance(t),n=this._get_neighbors(t);for(const i of n){if(i.processed)continue;const n=Math.max(s,r(t.element,i.element));e.raw_data().findIndex((t=>t.element==i))<0?(i.reachability_distance=n,e.push(i)):n<i.reachability_distance&&(i.reachability_distance=n,e=f.heapify(e.data(),(t=>t.reachability_distance),"min"))}}_expand_cluster(t,e){const r=this._ordered_list;for(;!t.empty;){const s=t.pop().element;s.neighbors=this._get_neighbors(s),s.processed=!0,e.push(s.index),r.push(s),null!=this._core_distance(s)&&(this._update(s,t),this._expand_cluster(t,e))}}get_clusters(){const t=[],e=[],r=this._min_points;for(const s of this._clusters)s.length<r?e.push(...s):t.push(s);return t.push(e),t}get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),r=this.get_clusters();for(let t=0,s=r.length;t<s;++t){const n=r[t];for(const r of n)e[r]=t<s-1?t:-1}return e}},t.PCA=y,t.Randomizer=c,t.SAMMON=class extends g{constructor(t,r){return super(t,{magic:.1,d:2,metric:e,seed:1212,init_DR:"random",init_parameters:{}},r),this}init(){const t=this.X.shape[0],{d:e,metric:r,init_DR:s,init_parameters:i}=this._parameters;if("random"===s){const r=this._randomizer;this.Y=new _(t,e,(()=>r.random))}else{if(!["PCA","MDS"].includes(s))throw new Error('init_DR needs to be either "random" or a DR method!');this.Y=_.from("PCA"==s?y.transform(this.X,i):A.transform(this.X,i))}return this.distance_matrix="precomputed"==r?_.from(this.X):n(this.X,r),this}transform(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,r=this.X.shape[0],{d:s,metric:n}=this._parameters;let i=this.Y,o=new _(r,s,0),a=new Float64Array(s);for(let h=0;h<r;++h){let l=new Float64Array(s),_=new Float64Array(s);const c=i.row(h);for(let t=0;t<r;++t){if(h===t)continue;const r=i.row(t),o=new Float64Array(s);for(let t=0;t<s;++t)o[t]=c[t]-r[t];const a=n(c,r),u=e.entry(h,t),d=u-a,f=Math.max(u*a,.01);for(let t=0;t<s;++t)l[t]+=o[t]*d/f,_[t]+=(d-Math.pow(o[t],2)*(1+d/a)/a)/f}for(let e=0;e<s;++e){const r=i.entry(h,e)+(t*l[e]/Math.abs(_[e])||0);o.set_entry(h,e,r),a[e]+=r}}for(let t=0;t<s;++t)a[t]/=r;for(let t=0;t<r;++t)for(let e=0;e<s;++e)i.set_entry(t,e,o.entry(t,e)-a[e]);return i}},t.SQDMDS=class extends g{constructor(t,r){return super(t,{d:2,metric:e,seed:1212,decay_start:.1,decay_cte:.34,init_DR:{type:"random"}},r),this}init(){const t=this._N,s=this.parameter("d");this._add=this.__add(s),this._sub_div=this.__sub_div(s),this._minus=this.__minus(s),this._mult=this.__mult(s),this._LR_init=Math.max(2,.005*t),this._LR=this._LR_init,this._offset=-Math.exp(-1/this.parameter("decay_cte")),this._momentums=new _(t,s,0),this._grads=new _(t,s,0),this._indices=i(0,t-1);const n=this._randomizer;this.Y=new _(t,s,(()=>n.random-.5));const o=this.parameter("metric");"precomputed"===o?(this._HD_metric=function(t,e,r){return r.entry(t,e)},this._HD_metric_exaggeration=function(t,e,r){return Math.pow(r.entry(t,e),2)}):(this._HD_metric=function(t,e,r){return o(r.row(t),r.row(e))},this._HD_metric_exaggeration=o==e?function(t,e,s){return r(s.row(t),s.row(e))}:function(t,e,r){return Math.pow(o(r.row(t),r.row(e)),2)})}transform(t=500){this.check_init(),this._decay_start=Math.round(this.parameter("decay_start")*t);for(let e=0;e<t;++e)this._step(e,t);return this.projection}*generator(t=500){this.check_init(),this._decay_start=Math.round(this.parameter("decay_start")*t);for(let e=0;e<t;++e)this._step(e,t),yield this.projection;return this.projection}_step(t,e){const r=this._decay_start;if(t>r){const s=this.parameter("decay_cte"),n=this._offset,i=(t-r)/(e-r);this._LR=this._LR_init*(Math.exp(-i*i/s)+n),this._distance_exaggeration=!1}else this._distance_exaggeration=!0;this._nestrov_iteration(this._distance_exaggeration)}__quartets(){const t=this._N,e=t-t%4,r=this._randomizer.choice(this._indices,e),s=[];for(let t=0;t<e;t+=4)s.push(Uint32Array.of(r[t],r[t+1],r[t+2],r[t+3]));return s}_nestrov_iteration(t){const e=this._momentums.mult(.99,{inline:!0}),r=this._LR,s=this._fill_MDS_grads(this.Y.add(e),this._grads,t),[n,i]=e.shape;for(let t=0;t<n;++t){const n=s.row(t),a=o(n);if(0==a)continue;const h=r/a,l=e.row(t);for(let t=0;t<i;++t)l[t]-=h*n[t]}this.Y.add(e,{inline:!0})}_fill_MDS_grads(t,e,r=!1,s=!0){s&&e.values.fill(0);const n=this._add,i=this.X;let o;o=1==r?this._HD_metric_exaggeration:this._HD_metric;const h=new Float64Array(6),l=this.__quartets();for(const[r,s,_,c]of l){h[0]=o(r,s,i),h[1]=o(r,_,i),h[2]=o(r,c,i),h[3]=o(s,_,i),h[4]=o(s,c,i),h[5]=o(_,c,i);const l=a(h);if(l>0)for(let t=0;t<6;++t)h[t]/=l,h[t]+=1e-11;const[u,d,f,m]=this._compute_quartet_grads(t,[r,s,_,c],h);n(e.row(r),u),n(e.row(s),d),n(e.row(_),f),n(e.row(c),m)}return e}_compute_quartet_grads(t,r,[s,n,i,o,h,l]){const[_,c,u,d]=r.map((e=>t.row(e))),f=e(_,c)+1e-12,m=e(_,u)+1e-12,p=e(_,d)+1e-12,w=e(c,u)+1e-12,g=e(c,d)+1e-12,y=e(u,d)+1e-12,A=a([f,m,p,w,g,y]),[x,M,b,v]=this._ABCD_grads(_,c,u,d,f,m,p,w,g,y,s,A),[z,j,E,N]=this._ABCD_grads(_,u,c,d,m,f,p,w,y,g,n,A),[D,k,X,B]=this._ABCD_grads(_,d,u,c,p,m,f,y,g,w,i,A),[F,$,L,Y]=this._ABCD_grads(c,u,_,d,w,f,g,m,y,p,o,A),[q,P,R,S]=this._ABCD_grads(c,d,_,u,g,f,w,p,y,m,h,A),[T,C,O,K]=this._ABCD_grads(u,d,_,c,y,m,w,p,g,f,l,A),U=this._add;return[U(x,z,D,L,R,O),U(M,E,B,F,q,K),U(b,j,X,$,S,T),U(v,N,k,Y,P,C)]}_ABCD_grads(t,e,r,s,n,i,o,a,h,l,_,c){const u=n/c,d=(_-u)/c*2,f=this._minus,m=this._add,p=this._mult,w=this._sub_div;return[p(f(p(m(w(t,e,n),w(t,r,i),w(t,s,o)),u),w(t,e,n)),d),p(f(p(m(w(e,t,n),w(e,r,a),w(e,s,h)),u),w(e,t,n)),d),p(m(w(r,t,i),w(r,e,a),w(r,s,l)),u*d),p(m(w(s,t,o),w(s,e,h),w(s,r,l)),u*d)]}__minus(t){return(e,r)=>{for(let s=0;s<t;++s)e[s]-=r[s];return e}}__add(t){return(...e)=>{const r=e.length,s=e[0];for(let n=1;n<r;++n){const r=e[n];for(let e=0;e<t;++e)s[e]+=r[e]}return s}}__mult(t){return(e,r)=>{for(let s=0;s<t;++s)e[s]*=r;return e}}__sub_div(t){return(e,r,s)=>Float64Array.from({length:t},((t,n)=>(e[n]-r[n])/s))}},t.TSNE=class extends g{constructor(t,e){return super(t,{perplexity:50,epsilon:10,d:2,metric:r,seed:1212},e),[this._N,this._D]=this.X.shape,this._iter=0,this.Y=new _(this._N,this.parameter("d"),(()=>1e-4*this._randomizer.gauss_random())),this}init(){const t=Math.log(this.parameter("perplexity")),e=this._N,r=this._D,{metric:s}=this._parameters,n=this.X;let i;if("precomputed"==s)i=druid.Matrix.from(n);else{i=new _(e,e);for(let t=0;t<e;++t){const r=n.row(t);for(let o=t+1;o<e;++o){const e=s(r,n.row(o));i.set_entry(t,o,e),i.set_entry(o,t,e)}}}const o=new _(e,e,0);this._ystep=new _(e,r,0),this._gains=new _(e,r,1);for(let r=0;r<e;++r){const s=i.row(r),n=o.row(r);let a,h=-1/0,l=1/0,_=1,c=50,u=!1;for(;!u&&c--;){a=0;let i=0;for(let t=0;t<e;++t){const e=s[t],o=r!==t?Math.exp(-e*_):0;i+=e*o,n[t]=o,a+=o}const o=a>0?Math.log(a)+_*i/a:0;o>t?(h=_,_=l===1/0?2*_:(_+l)/2):(l=_,_=h===-1/0?_/2:(_+h)/2),u=Math.abs(o-t)<1e-4}for(let t=0;t<e;++t)n[t]/=a}const a=2*e;for(let t=0;t<e;++t)for(let r=t;r<e;++r){const e=Math.max((o.entry(t,r)+o.entry(r,t))/a,1e-100);o.set_entry(t,r,e),o.set_entry(r,t,e)}return this._P=o,this}transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}*generator(t=500){this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}next(){const t=++this._iter,e=this._P,r=this._ystep,s=this._gains,n=this._N,{d:i,epsilon:o}=this._parameters;let a=this.Y;const h=t<100?4:1,l=new _(n,n,"zeros");let c=0;for(let t=0;t<n;++t)for(let e=t+1;e<n;++e){let r=0;for(let s=0;s<i;++s){const n=a.entry(t,s)-a.entry(e,s);r+=n*n}const s=1/(1+r);l.set_entry(t,e,s),l.set_entry(e,t,s),c+=2*s}const u=new _(n,n,0);for(let t=0;t<n;++t)for(let e=t+1;e<n;++e){const r=Math.max(l.entry(t,e)/c,1e-100);u.set_entry(t,e,r),u.set_entry(e,t,r)}const d=new _(n,i,"zeros");for(let t=0;t<n;++t)for(let r=0;r<n;++r){const s=4*(h*e.entry(t,r)-u.entry(t,r))*l.entry(t,r);for(let e=0;e<i;++e)d.add_entry(t,e,s*(a.entry(t,e)-a.entry(r,e)))}let f=new Float64Array(i);for(let e=0;e<n;++e)for(let n=0;n<i;++n){const i=d.entry(e,n),h=r.entry(e,n),l=s.entry(e,n);let _=Math.sign(i)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),s.set_entry(e,n,_);const c=(t<250?.5:.8)*h-o*_*i;r.set_entry(e,n,c),a.add_entry(e,n,c),f[n]+=a.entry(e,n)}for(let t=0;t<n;++t)for(let e=0;e<i;++e)a.sub_entry(t,e,f[e]/n);return this.Y}},t.TopoMap=class extends g{constructor(t,r){return super(t,{metric:e,seed:1212},r),[this._N,this._D]=this.X.shape,this._distance_matrix=new _(this._N,this._N,0),this}__lazy_distance_matrix(t,e,r){const s=this._distance_matrix,n=this.X,i=s.entry(t,e);if(0===i){let i=r(n.row(t),n.row(e));return s.set_entry(t,e,i),s.set_entry(e,t,i),i}return i}_make_minimum_spanning_tree(t=e){const r=this._N,s=[...this.X];let n=new m(s);const i=[];let o=[];for(let e=0;e<r;++e)for(let s=e+1;s<r;++s)o.push([e,s,this.__lazy_distance_matrix(e,s,t)]);o=o.sort(((t,e)=>t[2]-e[2]));for(const[t,e,r]of o){const o=n.find(s[t]),a=n.find(s[e]);o!==a&&(i.push([t,e,r]),n.union(o,a))}return i.sort(((t,e)=>t[2]-e[2]))}init(){const{metric:t}=this._parameters;return this.Y=new _(this._N,2,0),this._Emst=this._make_minimum_spanning_tree(t),this._is_initialized=!0,this}__hull_cross([t,e],[r,s],[n,i]){return(r-t)*(i-e)-(s-e)*(n-t)<=0}__hull(t){const e=t.sort((([t,e],[r,s])=>e-s||t-r)),r=e.length;if(r<=2)return e;const s=[];for(let t=0;t<r;++t){for(;s.length>=2&&this.__hull_cross(s[s.length-2],s[s.length-1],e[t]);)s.pop();s.push(e[t])}const n=[];for(let t=r-1;t>=0;--t){for(;n.length>=2&&this.__hull_cross(n[n.length-2],n[n.length-1],e[t]);)n.pop();n.push(e[t])}return n.pop(),s.pop(),s.concat(n)}__findAngle([t,r],[s,n]){const i=e([t,r],[s,n]);if(0===i)return{sin:0,cos:1};const o=[(s-t)/i,(n-r)/i],a=o[0];let h=Math.sqrt(1-a*a);return h=o[1]>=0?-h:h,{sin:h,cos:a}}__align_hull(t,r,s){let n,i,o,a=-1;for(let s=0;s<t.length;++s){const i=e(t[s],r);(-1===a||n>i)&&(n=i,a=s)}s?(i=t[a],o=t[(a+1)%t.length]):(0==a&&(a=t.length-1),i=t[a],o=t[(a-1)%t.length]);const h={tx:-t[a][0],ty:-t[a][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,o);h.sin=t,h.cos=e}else h.sin=0,h.cos=1;return h}__transform([t,e],{tx:r,ty:s,sin:n,cos:i}){let o=t+r,a=e+s;return[o*i-a*n,o*n+a*i]}__transform_component(t,e,r){const s=t.length;for(let n=0;n<s;++n){const s=t[n],[i,o]=this.__transform(s,e);s[0]=i,s[1]=o+r}}__align_components(t,e,r){const s=[...t.__disjoint_set.children],n=[...e.__disjoint_set.children],i=this.__hull(s),o=this.__hull(n),a=this.__align_hull(i,t,!1),h=this.__align_hull(o,e,!0);this.__transform_component(s,a,0),this.__transform_component(n,h,r)}transform(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new m(e.map(((t,e)=>(t.i=e,t))));for(const[s,n,i]of t){const t=r.find(e[s]),o=r.find(e[n]);t!==o&&(this.__align_components(t,o,i),r.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=this.Y.to2dArray,r=new m(e.map(((t,e)=>(t.i=e,t))));for(const[s,n,i]of t){const t=r.find(e[s]),o=r.find(e[n]);t!==o&&(this.__align_components(t,o,i),r.union(t,o),yield this.projection)}return this.projection}},t.TriMap=class extends g{constructor(t,r){return super(t,{weight_adj:500,c:5,d:2,metric:e,tol:1e-8,seed:1212},r),this}init(t=null,e=null){const r=this.X,s=r.shape[0],{c:n,d:i,metric:o,seed:a}=this._parameters;this.n_inliers=2*n,this.n_outliers=1*n,this.n_random=1*n,this.Y=t||new y(r,{d:i,seed:a}).transform(),this.knn=e||new p(r.to2dArray,o);const{triplets:h,weights:l}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=h,this.weights=l,this.lr=1e3*s/h.shape[0],this.C=1/0,this.vel=new _(s,i,0),this.gain=new _(s,i,1),this}_generate_triplets(t,e,r){const{metric:s,weight_adj:n}=this._parameters,i=this.X,o=i.shape[0],a=this.knn,h=Math.min(t+20,o),l=new _(o,h),c=new _(o,h);for(let t=0;t<o;++t)a.search(i.row(t),h+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,r)=>{l.set_entry(t,r,e.element.index),c.set_entry(t,r,e.value)}));const u=new Float64Array(o);for(let t=0;t<o;++t)u[t]=Math.max((c.entry(t,3)+c.entry(t,4)+c.entry(t,5)+c.entry(t,6))/4,1e-10);const d=this._find_p(c,u,l);let f=this._sample_knn_triplets(d,l,t,e),m=f.shape[0];const p=new Float64Array(m);for(let t=0;t<m;++t){const e=f.entry(t,0),r=f.entry(t,2);p[t]=s(i.row(e),i.row(r))}let w=this._find_weights(f,d,l,p,u);if(r>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(i,r,u);f=f.concat(t,"vertical"),w=Float64Array.from([...w,...e])}m=f.shape[0];let g=-1/0;for(let t=0;t<m;++t)isNaN(w[t])&&(w[t]=0),g<w[t]&&(g=w[t]);let y=-1/0;for(let t=0;t<m;++t)w[t]/=g,w[t]+=1e-4,w[t]=Math.log(1+n*w[t]),y<w[t]&&(y=w[t]);for(let t=0;t<m;++t)w[t]/=y;return{triplets:f,weights:w}}_find_p(t,e,r){const[s,n]=t.shape;return new _(s,n,((s,n)=>Math.exp(-(t.entry(s,n)**2)/e[s]/e[r.entry(s,n)])))}_sample_knn_triplets(t,e,r,s){const n=e.shape[0],i=new _(n*r*s,3);for(let o=0;o<n;++o){let a=o*r*s;const h=this.__argsort(t.row(o));for(let t=0;t<r;++t){let r=t*s;const l=e.entry(o,h[t]),_=this._rejection_sample(s,n,h.slice(0,t+1));for(let t=0;t<s;++t){const e=a+r+t,s=_[t];i.set_entry(e,0,o),i.set_entry(e,1,l),i.set_entry(e,2,s)}}}return i}__argsort(t){return i(0,t.length-1).sort(((e,r)=>t[r]-t[e]))}_rejection_sample(t,e,r){const s=this._randomizer,n=i(0,e-1).filter((t=>r.indexOf(t)<0));return s.choice(n,Math.min(t,n.length-2))}_find_weights(t,e,r,s,n){const i=t.shape[0],o=new Float64Array(i);for(let a=0;a<i;++a){const i=t.entry(a,0),h=r.row(i).indexOf(t.entry(a,1)),l=e.entry(i,h);let _=Math.exp(-(s[a]**2)/(n[i]*n[t.entry(a,2)]));_<1e-20&&(_=1e-20),o[a]=l/_}return o}_sample_random_triplets(t,e,r){const s=this.parameter("metric"),n=this._randomizer,o=t.shape[0],a=new _(o*e,3),h=new Float64Array(o*e);for(let l=0;l<o;++l){const _=l*e,c=[...i(0,l-1),...i(l+1,o-1)];for(let i=0;i<e;++i){let[e,o]=n.choice(c,2),u=Math.exp(-(s(t.row(l),t.row(e))**2)/(r[l]*r[e]));u<1e-20&&(u=1e-20);let d=Math.exp(-(s(t.row(l),t.row(o))**2)/(r[l]*r[o]));d<1e-20&&(d=1e-20),u<d&&([e,o]=[o,e],[u,d]=[d,u]);const f=_+i;a.set_entry(f,0,l),a.set_entry(f,1,e),a.set_entry(f,2,o),h[f]=u/d}}return{random_triplets:a,random_weights:h}}_grad(t){const e=this.n_inliers,r=this.n_outliers,s=this.triplets,n=this.weights,[i,o]=t.shape,a=s.shape[0],h=new _(i,o,0);let l=new Float64Array(o),c=new Float64Array(o),u=1,d=1,f=0,m=0;const p=i*e*r;for(let e=0;e<a;++e){const[i,a,_]=s.row(e);if(e%r==0||e>=p){u=1,d=1;for(let e=0;e<o;++e){const r=t.entry(i,e),s=t.entry(a,e),n=t.entry(_,e);l[e]=r-s,c[e]=r-n,u+=l[e]**2,d+=c[e]**2}}else{d=1;for(let e=0;e<o;++e){const r=t.entry(i,e),s=t.entry(_,e);c[e]=r-s,d+=c[e]**2}}u>d&&++f,m+=n[e]/(1+d/u);const w=(n[e]/(u+d))**2;for(let t=0;t<o;++t){const e=l[t]*d*w,r=c[t]*u*w;h.add_entry(i,t,e-r),h.sub_entry(a,t,e),h.add_entry(_,t,r)}}return{grad:h,loss:m,n_viol:f}}transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}*generator(t=800){this.check_init();for(let e=0;e<t;++e)this._next(e),yield this.projection;return this.projection}_next(t){const e=t>150?.5:.3,r=this.C,s=this.vel,n=this.Y.add(s.mult(e)),{grad:i,loss:o,n_viol:a}=this._grad(n);return this.C=o,this.Y=this._update_embedding(n,t,i),this.lr*=r>o+this._parameters.tol?1.01:.9,this.Y}_update_embedding(t,e,r){const[s,n]=t.shape,i=e>150?.9:.5,o=this.gain,a=this.vel,h=this.lr;for(let e=0;e<s;++e)for(let s=0;s<n;++s){const n=Math.sign(a.entry(e,s))!=Math.sign(r.entry(e,s))?o.entry(e,s)+.2:Math.max(.8*o.entry(e,s),.01);o.set_entry(e,s,n),a.set_entry(e,s,i*a.entry(e,s)-h*o.entry(e,s)*r.entry(e,s)),t.set_entry(e,s,t.entry(e,s)+a.entry(e,s))}return t}},t.UMAP=class extends g{constructor(t,r){if(super(t,{n_neighbors:15,local_connectivity:1,min_dist:1,d:2,metric:e,seed:1212,_spread:1,_set_op_mix_ratio:1,_repulsion_strength:1,_negative_sample_rate:5,_n_epochs:350,_initial_alpha:1},r),[this._N,this._D]=this.X.shape,this.parameter("n_neighbors")>this._N)throw new Error(`Parameter n_neighbors (=${this.parameter("n_neighbors")}) needs to be smaller than dataset size (N=${this._N})!`);if(this.parameter("local_connectivity")>this.parameter("n_neighbors"))throw new Error(`Parameter local_connectivity (=${this.parameter("local_connectivity")}) needs to be smaller than parameter n_neighbors (=${this.parameter("n_neighbors")})`);this._iter=0;const s=this._randomizer;return this.Y=new _(this._N,this.parameter("d"),(()=>s.random)),this}_find_ab_params(t,e){const r=i(0,3*t,300),s=i(0,3*t,300);for(let n=0,i=r.length;n<i;++n){const i=r[n];s[n]=i<e?1:Math.exp(-(i-e)/t)}return x((t=>{const e=i(1,300).map(((e,n)=>{return s[n]-(i=r[n],o=t[0],a=t[1],1/(1+o*Math.pow(i,2*a)));var i,o,a}));return Math.sqrt(a(e.map((t=>t*t))))}),[1,1])}_compute_membership_strengths(t,e,r){for(let s=0,n=t.length;s<n;++s){const n=r[s],i=t[s];for(let t=0,r=i.length;t<r;++t){const r=i[t].value-n;i[t].value=r>0?Math.exp(-r/e[s]):1}}return t}_smooth_knn_dist(t,e){const r=1e-5,s=.001,{local_connectivity:n,metric:i}=this._parameters,o=Math.log2(e),a=[],h=[],l=this.X,_=l.shape[0],c=[];if("precomputed"===i)for(let r=0;r<_;++r)c.push(t.search(r,e).reverse());else for(const r of l)c.push(t.search(r,e).raw_data().reverse());const u=Math.floor(n),d=n-u;for(let t=0;t<_;++t){let i=0,l=1/0,_=1,f=0;const m=c[t],p=m.filter((t=>t.value>0)),w=p.length;w>=n?u>0?(f=p[u-1].value,d>r&&(f+=d*(p[u].value-p[u-1].value))):f=d*p[0].value:w>0&&(f=p[w-1].value);for(let t=0;t<64;++t){let t=0;for(let r=0;r<e;++r){const e=m[r].value-f;t+=e>0?Math.exp(-e/_):1}if(Math.abs(t-o)<r)break;t>o?[l,_]=[_,(i+l)/2]:[i,_]=l===1/0?[_,2*_]:[_,(i+l)/2]}if(f>0){const t=m.reduce(((t,e)=>t+e.value),0)/m.length;_<s*t&&(_=s*t)}else{const t=c.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));_<s*t&&(_=s*t)}a[t]=f,h[t]=_}return{distances:c,sigmas:h,rhos:a}}_fuzzy_simplicial_set(t,e){const r=t.shape[0],{metric:s,_set_op_mix_ratio:n}=this._parameters,i="precomputed"===s?new w(t,"precomputed"):new p(t.to2dArray,s);let{distances:o,sigmas:a,rhos:h}=this._smooth_knn_dist(i,e);o=this._compute_membership_strengths(o,a,h);const l=new _(r,r,"zeros");for(let t=0;t<r;++t){const e=o[t];for(let r=0;r<e.length;++r)l.set_entry(t,e[r].element.index,e[r].value)}const c=l.T,u=l.mult(c);return l.add(c).sub(u).mult(n).add(u.mult(1-n))}_make_epochs_per_sample(t){const e=this._weights,r=new Float32Array(e.length).fill(-1),s=t/u(e);return e.forEach(((e,n)=>{const i=e*s;i>0&&(r[n]=Math.round(t/i))})),r}_tocoo(t){const e=[],r=[],s=[],[n,i]=t.shape;for(let o=0;o<n;++o)for(let n=0;n<i;++n){const i=t.entry(o,n);0!==i&&(e.push(o),r.push(n),s.push(i))}return{rows:e,cols:r,data:s}}init(){const{_spread:t,min_dist:e,n_neighbors:r,_n_epochs:s,_negative_sample_rate:n}=this._parameters,[i,o]=this._find_ab_params(t,e);this._a=i,this._b=o,this._graph=this._fuzzy_simplicial_set(this.X,r);const{rows:a,cols:h,data:l}=this._tocoo(this._graph);return this._head=a,this._tail=h,this._weights=l,this._epochs_per_sample=this._make_epochs_per_sample(s),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*n)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}transform(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}*generator(t=350){this.parameter("_n_epochs")!=t&&(this.parameter("_n_epochs",t),this.init()),this.check_init();for(let e=0;e<t;++e)this.next(),yield this.projection;return this.projection}_clip(t){return t>4?4:t<-4?-4:t}_optimize_layout(t,e,s,n){const i=this._randomizer,{_repulsion_strength:o,d:a}=this._parameters,{_alpha:h,_a:l,_b:_,_epochs_per_sample:c,_epochs_per_negative_sample:u,_epoch_of_next_negative_sample:d,_epoch_of_next_sample:f,_clip:m}=this,p=n.length;for(let w=0,g=c.length;w<g;++w)if(f[w]<=this._iter){const g=s[w],y=n[w],A=t.row(g),x=e.row(y),M=r(A,x);if(M>0){const t=-2*l*_*Math.pow(M,_-1)/(l*Math.pow(M,_)+1);for(let e=0;e<a;++e){const r=m(t*(A[e]-x[e]))*h;A[e]+=r,x[e]-=r}}f[w]+=c[w];const b=(this._iter-d[w])/u[w];for(let t=0;t<b;++t){const t=i.random_int%p,s=e.row(n[t]),c=r(A,s);if(c>0){const t=2*o*_/((.01+c)*(l*Math.pow(c,_)+1));for(let e=0;e<a;++e){const r=m(t*(A[e]-s[e]))*h;A[e]+=r,s[e]-=r}}else if(g===t)continue}d[w]+=b*u[w]}return t}next(){const t=++this._iter,e=this.Y,{_initial_alpha:r,_n_epochs:s}=this._parameters;return this._alpha=r*(1-t/s),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}},t.canberra=function(t,e){if(t.length!==e.length)return;const r=t.length;let s=0;for(let n=0;n<r;++n)s+=Math.abs(t[n]-e[n])/(Math.abs(t[n])+Math.abs(e[n]));return s},t.chebyshev=function(t,e){if(t.length!=e.length)return;const r=t.length;let s=[];for(let n=0;n<r;++n)s.push(Math.abs(t[n]-e[n]));return Math.max(...s)},t.cosine=function(t,e){if(t.length!==e.length)return;let r=t.length,s=0,n=0,i=0;for(let o=0;o<r;++o)s+=t[o]*e[o],n+=t[o]*t[o],i+=e[o]*e[o];return Math.acos(s/(Math.sqrt(n)*Math.sqrt(i)))},t.distance_matrix=n,t.euclidean=e,t.euclidean_squared=r,t.hamming=function(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let n=0;n<r;++n){s+=t[n]!=e[n]}return s/r},t.inner_product=function(t,e){const r=t.length;if(r!=e.length)throw new Error("Array a and b must have the same length!");let s=0;for(let n=0;n<r;++n)s+=t*e;return s},t.jaccard=function(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,n=0;for(let i=0;i<r;++i){const r=0!=t[i],o=0!=e[i];s+=r||o,n+=r&&o}return(s-n)/s},t.k_nearest_neighbors=s,t.kahan_sum=function(t){let e,r,s=t.length,n=0,i=0;for(let o=0;o<s;++o)e=t[o]-i,r=n+e,i=r-n-e,n=r;return n},t.linspace=i,t.manhattan=function(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let n=0;n<r;++n)s+=Math.abs(t[n]-e[n]);return s},t.max=u,t.min=d,t.neumair_sum=a,t.norm=o,t.normalize=function(t,r=e){const s=o(t,r);return t.map((t=>t/s))},t.powell=x,t.qr=h,t.qr_householder=function(t){const[e,r]=t.shape,s=new _(e,e,"I"),n=t.clone();for(let t=0;t<r;++t){const e=_.from(n.col(t).slice(t)),r=o(e),i=e.entry(0,0),a=-Math.sign(i),h=i-a*r,l=e.divide(h).set_entry(0,0,1),c=-a*h/r,u=l.outer(l),d=n.get_block(t,0),f=d.sub(u.dot(d).mult(c)),m=s.get_block(0,t),p=m.sub(m.dot(u).mult(c));n.set_block(t,0,f),s.set_block(0,t,p)}return{R:n,Q:s}},t.simultaneous_poweriteration=l,t.sokal_michener=function(t,e){if(t.length!=e.length)return;const r=t.length;let s=0;for(let n=0;n<r;++n){s+=0!=t[n]!=(0!=e[n])}return 2*s/(r+s)},t.version="0.6.3",t.yule=function(t,e){if(t.length!=e.length)return;const r=t.length;let s=0,n=0,i=0;for(let o=0;o<r;++o){const r=0!=t[o],a=0!=e[o];s+=r&&a,n+=r&&!a,i+=!r&&r}return 0==n||0==i?0:2*n*i/(s*(r-s-n-i)+n*i)},Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=druid.min.js.map
